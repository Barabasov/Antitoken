#pragma once

#include <winscard.h>
#include "Options.h"
#include "utils.h"

//
// APDU req and resp structures
//
// Responses:
//90 00 - OK
//69 85 - Conditions of use not stisfied
//63 00 - Authentication of host cryptogram failed (Ext auth)
//64 00 - No specific diagnosis
//67 00 - Wrong length in Lc
//67 XX - Error, incorrect parameter P3 (ISO code)    
//68 81 - Logical channel not supported or is not active 
//69 82 - Security status not satisfied
//69 83 - Secret code locked
//69 85 - No currently selected EF, no command to monitor / no Transaction Manager File 
//6A 80 - The parameters in the data field are incorrect 
//6A 81 - Card is blocked or command not supported 
//6A 82 - File not found  
//6A 85 - Lc inconsistent with TLV structure 
//6A 86 - Incorrect P1 P2
//6A 88 - Referenced data not found (Init upd)
//6D 00 - Invalid instruction
//6E 00 - Invalid class

//Class Byte Coding 
//00 - Command defined in ISO/IEC 7816 
//80 - Proprietary command
//84 - Proprietary command with secure messaging
//


const BYTE aladdinATR[] = { 0x3B, 0xD5, 0x18, 0x00, 0x81, 0x31, 0xFE, 0x7D, 0x80, 0x73, 0xC8, 0x21, 0x10, 0xF4 }; //Aladdin eToken Pro 72K
const BYTE laladdinATR = 14;
const BYTE resOK[] = { 0x90, 0x00 };
const BYTE noFile[] = { 0x6a, 0x82 };

//show contatiners
const BYTE s1[] = { 0x00, 0xA4, 0x04, 0x00, 0x07, 0xA0, 0x00, 0x00, 0x03, 0x12, 0x02, 0x02, 0x00 };
const BYTE ls1 = 13;
const BYTE s2[] = { 0x00, 0xA4, 0x08, 0x04, 0x06, 0x66, 0x66, 0x50, 0x00, 0x00, 0x0A, 0x00 };
const BYTE ls2 = 12;
const BYTE s3[] = { 0x80, 0x18, 0x00, 0x00, 0x04, 0x0E, 0x02, 0x00, 0x00, 0x02 };
const BYTE ls3 = 10;
const BYTE s4[] = { 0x00, 0xA4, 0x08, 0x04, 0x0A, 0x66, 0x66, 0x50, 0x00, 0xE0, 0x0E, 0x0B, 0x00, 0xCC, /*here container number*/0x00, 0x00 };
const BYTE ls4 = 16;
const BYTE s5[] = { 0x00, 0xA4, 0x08, 0x04, 0x0C, 0x66, 0x66, 0x50, 0x00, 0xE0, 0x0E, 0x0B, 0x00, 0xCC, /*here container number*/0x00, 0xF0, 0x06, 0x00 };
const BYTE ls5 = 18;
const BYTE s6[] = { 0x00, 0xA4, 0x08, 0x04, 0x0C, 0x66, 0x66, 0x50, 0x00, 0xE0, 0x0E, 0x0B, 0x00, 0xCC, /*here container number*/0x00, 0xF0, 0x03, 0x00 };
const BYTE ls6 = 18;
const BYTE s7[] = { 0x00, 0xA4, 0x08, 0x04, 0x0C, 0x66, 0x66, 0x50, 0x00, 0xE0, 0x0E, 0x0B, 0x00, 0xCC, /*here container number*/0x00, 0xF0, 0x01, 0x00 };
const BYTE ls7 = 18;
const BYTE s11[] = { 0x00, 0xA4, 0x08, 0x04, 0x0C, 0x66, 0x66, 0x50, 0x00, 0xE0, 0x0E, 0x0B, 0x00, 0xCC, /*here container number*/0x00, 0xF0, 0x02, 0x00 };
const BYTE ls11 = 18;

const BYTE s8[] = { 0x00, 0xA4, 0x08, 0x04, 0x04, 0x66, 0x66, 0x50, 0x00, 0x00 };
const BYTE ls8 = 10;
const BYTE s9[] = { 0x80, 0x07, 0x00, 0x11, 0x05, 0x10, 0x03, 0x23, 0x06, 0x20, 0x00 };
const BYTE ls9 = 11;
const BYTE s10[] = { 0x00, 0xA4, 0x08, 0x04, 0x06, 0x66, 0x66, 0x50, 0x00, 0x00, 0x0F, 0x00 };
const BYTE ls10 = 12;

const BYTE cmdSELECT[] = { 0x00, 0xA4, 0x04, 0x00, /*0x07, 0xA0, 0x00, 0x00, 0x01, 0x51, 0x00, 0x00, 0x00*/ }; //select security domain
const BYTE cmdINIT_UPD[] = { 0x80, 0x50, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; //initialize update
const BYTE cmdEXT_AUTH[] = { 0x84, 0x82, 0x03, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; //external authenticate

const BYTE cmdGIVE_RTE20[] = { 0x80, 0x18, 0x00, 0x00, 0x04, 0x0E, 0x02, 0x00, 0x00, 0x14 };//request for token data 20 byte 
const BYTE lcmdGIVE_RTE20 = 10;
const BYTE cmd8017[] = { 0x80, 0x17, 0x00, 0x00, 0x08 };//request for challenge
const BYTE lcmd8017 = 5;
const BYTE cmd8011[] = { 0x80, 0x11, 0x00, 0x11, 0x0A, 0x10, 0x08, 0x3F, 0x5F, 0x98, 0xD9, 0x37, 0xAE, 0x75, 0x00 };//send response to challenge (rewrite last 8 bytes)
const BYTE lcmd8011 = 15;

const BYTE cmdGIVE_ALL_name[] = { 0x80, 0x18, 0x00, 0x00, 0x04, 0x0E, 0x02, 0x00, 0x00, 0x44 };//give full name of container
const BYTE lcmdGIVE_ALL_name = 10;
const BYTE cmdGIVE_10[] = { 0x80, 0x18, 0x00, 0x00, 0x04, 0x0E, 0x02, 0x00, 0x00, 0x0A };//give first 10 bytes
const BYTE lcmdGIVE_10 = 10;

const BYTE cmdGET_PRIMARY[] = { 0x80, 0x18, 0x00, 0x00, 0x04, 0x0E, 0x02, 0x00, 0x00, 0x24 };//36b reply
const BYTE lcmdGET_PRIMARY = 10;
const BYTE cmdGET_MASKS[]   = { 0x80, 0x18, 0x00, 0x00, 0x04, 0x0E, 0x02, 0x00, 0x00, 0x38 };//56b reply
const BYTE lcmdGET_MASKS = 10;


class Token
{
public:
	BYTE ATR[128];
	DWORD lATR=128; //actual length of ATR

	Token(Options opt);
	Token();
	~Token();

	LONG establish_token();
	TCHAR reader[260]; //reader name
	DWORD lreader = 260;

	bool checkATR();
	int dump_name(vector<BYTE> &res, DWORD id);
	int dump_masks(vector<BYTE> &res, DWORD id);
	int dump_primary(vector<BYTE> &res, DWORD id);
	int dump_header(vector<BYTE> &res, DWORD id);
	void list_containers(vector<string> &res);
	int et72k_Login();
	void sendAPDUFromFile(char *filename);

	int setUpass(char *p);

private:
	SCARDCONTEXT    hSC;
	SCARDHANDLE     hCardHandle;
	bool debug = false;
	//bool loggedin = false; //if token is logged in

	
	DWORD lpass = 260;
	char upass[260]; //user password
	char apass[260]; //admin password

	void sendPreambula();
	void coumpute_authcode(BYTE challenge[8], BYTE rte_data[20]);
	void magic_sum64(BYTE out[64], BYTE v1[20], BYTE v2[64]);
	void invert_bytes(BYTE a[], int n);
};

